<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Detector</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        .split-view {
            display: grid;
            grid-template-columns: 1fr 1fr;
            width: 100vw;
            height: 100vh;
        }

        .panel {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        #videoElement {
            display: none;
        }

        #canvasElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #memeImage {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
        }
    </style>
</head>
<body>
    <div class="split-view">
        <div class="panel">
            <video id="videoElement" autoplay playsinline></video>
            <canvas id="canvasElement"></canvas>
        </div>
        
        <div class="panel">
            <img id="memeImage" src="blank.jpg" alt="">
        </div>
    </div>

    <script type="module">
        import { FaceLandmarker, HandLandmarker, FilesetResolver } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14';

        // Configuration
        const DISTANCE_THRESHOLD = 0.08;
        const VIDEO_WIDTH = 640;
        const VIDEO_HEIGHT = 480;
        const GESTURE_HISTORY_SIZE = 5; // Increased for better smoothing
        const NO_HAND_THRESHOLD = 8; // Need 8 consecutive frames with no hand to show blank
        const MIN_DETECTION_CONFIDENCE = 0.7;
        const MIN_TRACKING_CONFIDENCE = 0.7;

        // Global variables
        let faceLandmarker;
        let handLandmarker;
        let video;
        let canvas;
        let ctx;
        let memeImage;
        let lastVideoTime = -1;

        // Gesture state tracking
        let currentDisplayedState = 'blank.jpg';
        let gestureHistory = [];
        let noHandFrameCount = 0;

        // Image states
        const MEME_STATES = {
            BLANK: 'blank.jpg',
            SMILE: 'smile.jpg',
            THINK: 'think.jpg'
        };

        // Initialize the application
        async function init() {
            try {
                // Initialize MediaPipe
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
                );

                // Create Face Landmarker
                faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',
                        delegate: "GPU"
                    },
                    outputFaceBlendshapes: false,
                    outputFacialTransformationMatrixes: false,
                    runningMode: "VIDEO",
                    numFaces: 1,
                    minDetectionConfidence: MIN_DETECTION_CONFIDENCE,
                    minTrackingConfidence: MIN_TRACKING_CONFIDENCE
                });

                // Create Hand Landmarker
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1,
                    minHandDetectionConfidence: MIN_DETECTION_CONFIDENCE,
                    minHandPresenceConfidence: MIN_TRACKING_CONFIDENCE,
                    minTrackingConfidence: MIN_TRACKING_CONFIDENCE
                });

                // Setup video and canvas
                await setupCamera();

                // Get meme image element
                memeImage = document.getElementById('memeImage');

                // Start the detection loop
                detectGesture();

            } catch (error) {
                console.error('Initialization error:', error);
            }
        }

        // Setup camera
        async function setupCamera() {
            video = document.getElementById('videoElement');
            canvas = document.getElementById('canvasElement');
            ctx = canvas.getContext('2d');

            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: VIDEO_WIDTH,
                    height: VIDEO_HEIGHT,
                    facingMode: 'user'
                },
                audio: false
            });

            video.srcObject = stream;
            
            return new Promise((resolve) => {
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    resolve();
                };
            });
        }

        // Calculate distance between two points in normalized coordinates
        function calculateDistance(point1, point2) {
            const dx = point1.x - point2.x;
            const dy = point1.y - point2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Determine the most common gesture in recent history
        function getMostCommonGesture(history) {
            if (history.length === 0) return null;
            
            const counts = {};
            for (let gesture of history) {
                counts[gesture] = (counts[gesture] || 0) + 1;
            }
            
            let maxCount = 0;
            let mostCommon = null;
            for (let gesture in counts) {
                if (counts[gesture] > maxCount) {
                    maxCount = counts[gesture];
                    mostCommon = gesture;
                }
            }
            
            return mostCommon;
        }

        // Detect gesture and render
        async function detectGesture() {
            if (!video || video.readyState !== 4) {
                requestAnimationFrame(detectGesture);
                return;
            }

            const currentTime = performance.now();
            
            // Draw video frame to canvas (mirrored)
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.scale(-1, 1);
            ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
            ctx.restore();

            let detectedGesture = null;

            // Detect face and hand
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                
                const faceResults = faceLandmarker.detectForVideo(video, currentTime);
                const handResults = handLandmarker.detectForVideo(video, currentTime);

                // Process hand landmarks
                if (handResults.landmarks && handResults.landmarks.length > 0) {
                    // Hand detected - reset no-hand counter
                    noHandFrameCount = 0;
                    
                    const hand = handResults.landmarks[0];
                    
                    // Default: hand detected - show smile
                    detectedGesture = MEME_STATES.SMILE;

                    // Check if face is also detected for mouth proximity
                    if (faceResults.faceLandmarks && faceResults.faceLandmarks.length > 0) {
                        const faceLandmarks = faceResults.faceLandmarks[0];
                        const upperLip = faceLandmarks[13];
                        const indexFingerTip = hand[8];

                        // Calculate distance between index finger tip and upper lip
                        const distance = calculateDistance(indexFingerTip, upperLip);

                        // If finger is near mouth, show think.jpg
                        if (distance < DISTANCE_THRESHOLD) {
                            detectedGesture = MEME_STATES.THINK;
                        }
                    }
                } else {
                    // No hand detected - increment counter
                    noHandFrameCount++;
                }
            }

            // Update gesture history only if hand is detected
            if (detectedGesture !== null) {
                gestureHistory.push(detectedGesture);
                if (gestureHistory.length > GESTURE_HISTORY_SIZE) {
                    gestureHistory.shift();
                }
            }

            // Determine which state to display with priority logic
            let newState;
            
            if (noHandFrameCount > NO_HAND_THRESHOLD) {
                // Only show blank after many consecutive frames with no hand
                newState = MEME_STATES.BLANK;
                gestureHistory = []; // Clear history when going to blank
            } else if (gestureHistory.length > 0) {
                // If we have recent gesture history, use the most common one
                const mostCommon = getMostCommonGesture(gestureHistory);
                newState = mostCommon || currentDisplayedState;
            } else {
                // Keep current state if no clear signal
                newState = currentDisplayedState;
            }

            // Update displayed state
            if (newState !== currentDisplayedState) {
                currentDisplayedState = newState;
                memeImage.src = newState;
            }

            // Continue the loop
            requestAnimationFrame(detectGesture);
        }

        // Start the application
        init();
    </script>
</body>
</html>
